import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.math3.ml.distance.EuclideanDistance;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class LOFJavaExample {
    public static void main(String[] args) {
        // Specify the input file path
        String inputFilePath = "/home/hadoop/IST3134/predata2/half1";
        // Specify the output file path
        String outputFilePath = "/home/hadoop/IST3134/maplof.csv";
        String outputResultFilePath = "/home/hadoop/IST3134/mapresult.csv";

        long startTime = System.nanoTime();

        try {
            // Load the data and filter out rows with NA values in 'SPEED', 'TRAVEL_TIME', or 'BOROUGH' columns
            List<DataRecord> dataRecords = loadData(inputFilePath);

            // Take a random sample
            int sampleSize = 150000;
            List<DataRecord> dataSample = takeRandomSample(dataRecords, sampleSize);

            // Run the LOF algorithm on the data sample
            double[] lofScores = calculateLOFScores(dataSample);

            // Add the LOF scores to the data sample
            addLOFScores(dataSample, lofScores);

            // Write results to CSV file
            writeDataToCSV(dataSample, outputFilePath);

            // Perform data manipulations and save the final result to CSV file
            manipulateAndSaveResult(dataSample, outputResultFilePath);

            System.out.println("Result saved to: " + outputResultFilePath);
        } catch (IOException e) {
            e.printStackTrace();
        }

        long endTime = System.nanoTime();
        long executionTime = endTime - startTime;
        long executionTimeInSeconds = executionTime / 1_000_000_000; // Convert nanoseconds to seconds

        System.out.println("Execution Time: " + executionTimeInSeconds + " seconds");
    }

private static List<DataRecord> loadData(String filePath) throws IOException {
    // ... (load data from CSV and return a list of DataRecord objects)
    // Example:
    List<DataRecord> dataRecords = new ArrayList<>();
    // ... (load data and add it to dataRecords)
    return dataRecords;
}

private static List<DataRecord> takeRandomSample(List<DataRecord> dataRecords, int sampleSize) {
    // ... (take a random sample of the specified size and return it)
    // Example:
    List<DataRecord> dataSample = new ArrayList<>();
    // ... (take the random sample from dataRecords and add it to dataSample)
    return dataSample;
}
    private static double sumOfKNearestDistances(double[] distances, int k) {
        Arrays.sort(distances);
        double sum = 0;
        for (int i = 0; i < k; i++) {
            sum += distances[i];
        }
        return sum;
    }

    private static double sumOfKLocalReachabilityDensity(double[] distances, int k, double lrd) {
        Arrays.sort(distances);
        double sum = 0;
        for (int i = 0; i < k; i++) {
            sum += Math.max(lrd, distances[i]);
        }
        return sum;
    }
private static double[] calculateLOFScores(List<DataRecord> dataSample) {
    int k = 5; // number of neighbors for LOF
    double[] lofScores = new double[dataSample.size()];
    EuclideanDistance euclideanDistance = new EuclideanDistance();

    for (int i = 0; i < dataSample.size(); i++) {
        DataRecord currentRecord = dataSample.get(i);
        double[] distances = new double[dataSample.size()];

        for (int j = 0; j < dataSample.size(); j++) {
            DataRecord otherRecord = dataSample.get(j);
            distances[j] = euclideanDistance.compute(
                    new double[]{currentRecord.speed, currentRecord.travelTime},
                    new double[]{otherRecord.speed, otherRecord.travelTime}
            );
        }

        Arrays.sort(distances);
        double kthDistance = distances[k];
        double lrd = k / (sumOfKNearestDistances(distances, k) * Math.PI * kthDistance * kthDistance);
        double lof = sumOfKLocalReachabilityDensity(distances, k, lrd) / (lrd * k);
        lofScores[i] = lof;
    }

    return lofScores; 
}


    private static void addLOFScores(List<DataRecord> dataSample, double[] lofScores) {
        // ... (add the LOF scores to the data sample)
    }

    private static void writeDataToCSV(List<DataRecord> dataSample, String outputFilePath) throws IOException {
        // ... (write the data sample to CSV file)
    }

    private static void manipulateAndSaveResult(List<DataRecord> dataSample, String outputResultFilePath) throws IOException {
        // ... (perform data manipulations, save the final result to CSV file)
    }

    private static class DataRecord {
        double speed;
        double travelTime;
        String borough;
        double lofScore;
        int hasNA;

        public DataRecord(double speed, double travelTime, String borough) {
            this.speed = speed;
            this.travelTime = travelTime;
            this.borough = borough;
        }
    }
}
